package com.unilog.prime.dbcore.service.impl;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.SelectJoinStep;
import org.jooq.SortField;
import org.jooq.SortOrder;
import org.jooq.Table;
import org.jooq.UpdatableRecord;
import org.jooq.impl.DSL;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.repository.support.PageableExecutionUtils;
import org.springframework.http.HttpStatus;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.Assert;

import com.unilog.prime.commons.enumeration.PrimeResponseCode;
import com.unilog.prime.commons.exception.PrimeException;
import com.unilog.prime.commons.exception.ResourceAlreadyExistException;
import com.unilog.prime.commons.model.AbstractDomainModel;
import com.unilog.prime.commons.service.IBaseDomainService;
import com.unilog.prime.commons.service.impl.AbstractDomainServiceImpl;
import com.unilog.prime.commons.util.BooleanUtil;
import com.unilog.prime.commons.util.StringUtil;
import com.unilog.prime.commons.util.TextUtil;

@Transactional
public abstract class AbstractJooqDatabaseServiceImpl<R extends UpdatableRecord<R>, I extends Serializable, P extends AbstractDomainModel<I>>
		extends AbstractDomainServiceImpl<P, I> implements IBaseDomainService<P, I> {

	private static final String UPDATED_BY = "UPDATED_BY";
	public static final String SIZE = "size";
	public static final String SORT = "sort";
	public static final String PAGE = "page";

	@Autowired
	protected DSLContext dslContext;

	protected final Table<R> table;
	protected final Field<I> idField;
	protected final Field<?> updatedByField;

	public AbstractJooqDatabaseServiceImpl(Table<R> table, Field<I> idField) {
		super();
		this.table = table;
		this.idField = idField;
		this.updatedByField = table.field(UPDATED_BY);
	}

	@Override
	public Page<P> list(Pageable pageable) {
		SelectJoinStep<Record> selectJoinStep = getSelectJointStep();
		return list(pageable, selectJoinStep);
	}

	@Override
	public Page<P> list(Pageable pageable, Map<String, Object> filterQuery) {
		SelectJoinStep<Record> selectJoinStep = getSelectJointStep();
		// apply where clause based conditions generated by filter query map
		if (filterQuery != null) {
			filterQuery.remove(SIZE);
			filterQuery.remove(SORT);
			filterQuery.remove(PAGE);
			selectJoinStep.where(filter(filterQuery));
		}
		return list(pageable, selectJoinStep);
	}
	
	protected Page<P> list(Pageable pageable, SelectJoinStep<Record> selectJoinStep) {
		List<SortField<?>> orderBy = new ArrayList<>();
		if (pageable.getSort() != null) {
			pageable.getSort().forEach(order -> {
				Field<?> field = this.getField(order.getProperty());
				if (field != null) {
					orderBy.add(selectJoinStep.getSelect().get(
							getAliasFieldIndex(selectJoinStep, order.getProperty())).sort(
									order.getDirection() == Direction.ASC ? SortOrder.ASC : SortOrder.DESC));
				}
			});
		}
		// apply sort logic
		if (!orderBy.isEmpty()) {
			selectJoinStep.orderBy(orderBy);
		}	
		int count = dslContext.fetchCount(selectJoinStep);
		List<P> recordsList = selectJoinStep.limit(pageable.getPageSize()).offset((int) pageable.getOffset())
				.fetchInto(pojoClass);
		return PageableExecutionUtils.getPage(recordsList, pageable, () -> count);
	}
	
	private int getAliasFieldIndex(SelectJoinStep<Record> sjs, String propertyName) {
		int index=0;
		String newPropertyName = this.convertToJOOQFieldName(propertyName);
		try {
		    while(true) {
				String fieldName = sjs.getSelect().get(index).getUnqualifiedName().toString();
				fieldName = fieldName.substring(1, fieldName.length()-1);
				if(fieldName.equals(newPropertyName)) { 
				    return index;
				}
				else index ++;
		    }
		}catch(Exception e) {
			e.printStackTrace();
			throw new PrimeException(HttpStatus.BAD_REQUEST, PrimeResponseCode.REQUIRED_FIELD.getResponseMsg(),
					PrimeResponseCode.REQUIRED_FIELD.getResponseCode());
		}	
    }
	
	public List<P> listAll(Map<String, Object> query) {
		SelectJoinStep<Record> selectJoinStep = getSelectJointStep();
		if (query != null) {
			//TODO: Need to add sort logic.
			query.remove(SORT);
			selectJoinStep.where(filter(query));
		}
		return selectJoinStep.fetchInto(pojoClass);
	}

	protected SelectJoinStep<Record> getSelectJointStep() {
		return dslContext.select(Arrays.asList(table.fields())).from(table);
	}

	@Override
	public P getById(I id) {
		R record = getRecordById(id);
		return record.into(pojoClass);
	}

	protected String convertToJOOQFieldName(String fieldName) {
		return fieldName.replaceAll("([A-Z])", "_$1").toUpperCase();
	}

	@Override
	public P update(I id, Map<String, Object> updateFields) {
		if (updateFields.containsKey("createdAt"))
			updateFields.remove("createdAt");
		R record = getRecordById(id);
		logger.debug("found record {}", record);
		Map<Field<?>, Object> tableFieldsMap = new HashMap<>();
		updateFields.keySet().forEach(updateField -> {
			Field<?> pojoField = this.getField(updateField);
			if (pojoField != null) {
				if (updateFields.get(updateField) instanceof String)
					tableFieldsMap.put(pojoField, TextUtil.anyToDBFormat(StringUtil.ifEmptyMakeItNull(
							updateFields.get(updateField) == null ? null : updateFields.get(updateField).toString())));
				else
					tableFieldsMap.put(pojoField, updateFields.get(updateField));
			}
		});
		
		if (updatedByField != null)
			tableFieldsMap.put(updatedByField, getCurrentlyLoggedInUserId());

		try {
			int updatedCount = dslContext.update(table).set(tableFieldsMap).where(idField.eq(id)).execute();
			logger.debug("UpdatedCount {} once after updating {} table", updatedCount, table);
		} catch (DuplicateKeyException dkException) {
			throw new PrimeException(HttpStatus.CONFLICT, PrimeResponseCode.RESOURCE_ALREADY_EXISTS.getResponseMsg(),
					dkException, PrimeResponseCode.RESOURCE_ALREADY_EXISTS.getResponseCode(), dkException.getMessage());
		}

		return getById(id);
	}

	@Override
	public P create(P pojo) {
		try {
			R record = newRecord(preCreate(pojo));
			logger.debug("record {}", record);
			record.store();
			return record.into(pojoClass);
		} catch (DuplicateKeyException dkException) {
			throw new ResourceAlreadyExistException(HttpStatus.CONFLICT,
					PrimeResponseCode.RESOURCE_ALREADY_EXISTS.getResponseMsg(), dkException,
					PrimeResponseCode.RESOURCE_ALREADY_EXISTS.getResponseCode(), dkException.getMessage());
		}
	}

	protected P preCreate(P pojo) {
		Assert.notNull(pojo, "Entity can't be null");
		pojo.setId(null);
		pojo.setCreatedBy(getCurrentlyLoggedInUserId());
		return pojo;
	}

	protected abstract I getCurrentlyLoggedInUserId();

	@Override
	public P put(P entity) {
		throw new PrimeException(HttpStatus.METHOD_NOT_ALLOWED,
				PrimeResponseCode.PUT_METHOD_NOT_ALLOWED.getResponseMsg(),
				PrimeResponseCode.PUT_METHOD_NOT_ALLOWED.getResponseCode());
	}

	@Override
	public void delete(I id) {
		try {
			dslContext.delete(table).where(idField.eq(id)).execute();
		} catch (DataIntegrityViolationException diException) {
			throw new PrimeException(HttpStatus.PRECONDITION_FAILED,
					PrimeResponseCode.RESOURCE_IS_IN_USE.getResponseMsg(), diException,
					PrimeResponseCode.RESOURCE_IS_IN_USE.getResponseCode(), diException.getMessage());
		}
	}
	
	protected Field<?> getField(String fieldName) {
		return table.field(convertToJOOQFieldName(fieldName));
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected Condition filter(Map<String, Object> filterQuery) {
		List<Condition> conditions = new ArrayList<>();
		filterQuery.keySet().forEach(fieldKey -> {
			Field field = this.getField(fieldKey);
			if (field == null) {

				logger.debug("Unable to find field {}", fieldKey);
				return;
			}
			logger.debug("field {}", field.getName());
			if (field.getDataType() == null)
				return;
			final Object value = filterQuery.get(fieldKey);
			if (value instanceof List) {
				conditions.add(field.in(value));
			} else if (field.getDataType().isString())
				conditions.add(field.like("%" + TextUtil.anyToDBFormat(value.toString()) + "%"));
			else if (field.getDataType().isNumeric() && value != null) {
				try {
					conditions.add(field.eq((field.getDataType().hasPrecision() ? Double.valueOf(value.toString())
							: Long.valueOf(value.toString()))));
				} catch (Exception ex) {
					this.logger.debug("Unable to convert value {} to a double or long", value, ex);
					conditions.add(field.eq(BooleanUtil.convertToBoolean(value) ? 1 : 0));
				}				
			} else
				conditions.add(field.eq(value));
		});

		logger.debug("Conditions {}", conditions);

		return DSL.and(conditions);
	}

	protected R getRecordById(I id) {
		R record = dslContext.selectFrom(table).where(idField.eq(id)).fetchOne();
		if (record == null)
			throw new PrimeException(HttpStatus.NOT_FOUND,
					String.format(PrimeResponseCode.RESOURCE_NOT_FOUND.getResponseMsg(), id),
					PrimeResponseCode.RESOURCE_NOT_FOUND.getResponseCode());
		return record;
	}

	protected R newRecord(Object obj) {
		return dslContext.newRecord(table, obj);
	}

	@Override
	public boolean exists(I id) {
		boolean found = (dslContext.fetchExists(dslContext.selectFrom(table).where(idField.eq(id))));
		if (!found)
			throw new PrimeException(HttpStatus.NOT_FOUND,
					String.format(PrimeResponseCode.RESOURCE_NOT_FOUND.getResponseMsg(), id),
					PrimeResponseCode.RESOURCE_NOT_FOUND.getResponseCode());
		return found;
	}

	public void setDslContext(DSLContext dslContext) {
		this.dslContext = dslContext;
	}
}
